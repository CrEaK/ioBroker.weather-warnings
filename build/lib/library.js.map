{
  "version": 3,
  "sources": ["../../src/lib/library.ts"],
  "sourcesContent": ["import jsonata from 'jsonata';\nimport { genericStateObjects, statesObjectsWarningsType } from './def/definitionen';\nimport WeatherWarnings from '../main';\n\nimport { customFormatedTokensJson, textLevels } from './def/messages-def';\nimport { geti18nTranslation, seti18nTranslation, writefile } from './translations';\n\n// only change this for other adapters\ntype AdapterClassDefinition = WeatherWarnings;\n\ntype LibraryStateVal = LibraryStateValJson | undefined;\ntype LibraryStateValJson = {\n    type: ioBroker.ObjectType;\n    stateTyp: string | undefined;\n    val: ioBroker.StateValue | undefined;\n    ts: number;\n    ack: boolean;\n};\n\n// Generic library module and base classes, do not insert specific adapter code here.\n\n/**\n * Base class with this.log function\n */\nexport class BaseClass {\n    unload: boolean = false;\n    log: CustomLog;\n    adapter: AdapterClassDefinition;\n    name: string = ``;\n    constructor(adapter: AdapterClassDefinition, name: string = '') {\n        this.name = name;\n        this.log = new CustomLog(adapter, this.name);\n        this.adapter = adapter;\n    }\n    delete(): void {\n        this.unload = true;\n    }\n}\n\nclass CustomLog {\n    #adapter: AdapterClassDefinition;\n    #prefix: string;\n    constructor(adapter: AdapterClassDefinition, text: string = '') {\n        this.#adapter = adapter;\n        this.#prefix = text;\n    }\n    getName(): string {\n        return this.#prefix;\n    }\n    debug(log: string, log2: string = ''): void {\n        this.#adapter.log.debug(log2 ? `[${log}] ${log2}` : `[${this.#prefix}] ${log}`);\n    }\n    info(log: string, log2: string = ''): void {\n        this.#adapter.log.info(log2 ? `[${log}] ${log2}` : `[${this.#prefix}] ${log}`);\n    }\n    warn(log: string, log2: string = ''): void {\n        this.#adapter.log.warn(log2 ? `[${log}] ${log2}` : `[${this.#prefix}] ${log}`);\n    }\n    error(log: string, log2: string = ''): void {\n        this.#adapter.log.error(log2 ? `[${log}] ${log2}` : `[${this.#prefix}] ${log}`);\n    }\n    setLogPrefix(text: string): void {\n        this.#prefix = text;\n    }\n}\n\nexport class Library extends BaseClass {\n    stateDataBase: { [key: string]: LibraryStateVal } = {};\n    language: string = 'en';\n    allowedDirs: string[] = [];\n    translation: { [key: string]: string } = {};\n    constructor(adapter: AdapterClassDefinition, _options: any = null) {\n        super(adapter, 'library');\n        this.stateDataBase = {};\n    }\n\n    /**\n     * Write/create from a Json with defined keys, the associated states and channels\n     * @param prefix iobroker datapoint prefix where to write\n     * @param objNode Entry point into the definition json.\n     * @param def the definition json\n     * @param data The Json to read\n     * @param expandTree expand arrays up to 99\n     * @returns  void\n     */\n    async init(): Promise<void> {\n        const obj = await this.adapter.getForeignObjectAsync('system.config');\n        if (obj) {\n            await this.setLanguage(obj.common.language);\n        }\n\n        await this.updateTranslations();\n    }\n\n    async writeFromJson(\n        // provider.dwd.*warncellid*.warnung*1-5*\n        prefix: string,\n        objNode: string, // the json path to object def for jsonata\n        def: statesObjectsWarningsType,\n        data: any,\n        expandTree: boolean = false,\n    ): Promise<void> {\n        if (!def || typeof def !== 'object') return;\n        if (data === undefined || ['string', 'number', 'boolean', 'object'].indexOf(typeof data) == -1) return;\n        // wir arbeiten immer nur mit einem Datenpunkt ist dieses ein json wird mit expandTree recrusise aufgerufen f\u00FCr arrays erstmal immer plain\n        const objectDefinition = objNode ? await this.getObjectDefFromJson(`${objNode}`, def) : null;\n\n        if (objectDefinition)\n            objectDefinition.native = {\n                ...(objectDefinition.native || {}),\n                objectDefinitionReference: objNode,\n            };\n\n        if (typeof data === 'object' && data !== null) {\n            // handle array\n            if (Array.isArray(data)) {\n                if (!objectDefinition) return;\n                if (this.adapter.config.expandArray || objectDefinition.type !== 'state' || expandTree) {\n                    let a = 0;\n                    for (const k in data) {\n                        const defChannel = this.getChannelObject(objectDefinition);\n\n                        const dp = `${prefix}${`00${a++}`.slice(-2)}`;\n                        // create folder\n                        await this.writedp(dp, null, defChannel);\n\n                        await this.writeFromJson(dp, `${objNode}`, def, data[k], expandTree);\n                    }\n                } else {\n                    this.writeFromJson(prefix, objNode, def, JSON.stringify(data) || '[]', expandTree);\n                }\n                //objectDefinition._id = `${this.adapter.name}.${this.adapter.instance}.${prefix}.${key}`;\n            } else {\n                // create folder\n                if (objectDefinition) {\n                    const defChannel = this.getChannelObject(objectDefinition);\n                    await this.writedp(prefix, null, defChannel);\n                }\n                if (data === null) return;\n\n                for (const k in data) {\n                    await this.writeFromJson(`${prefix}.${k}`, `${objNode}.${k}`, def, data[k], expandTree);\n                }\n            }\n        } else {\n            if (!objectDefinition) return;\n            await this.writedp(prefix, data, objectDefinition);\n        }\n        /**\n         * \u00FCberlegungen zur Defintion von states\n         * const def : {id: objectdefinition...}\n         * bei objecten im State funktioniert es nicht gleichzeitig den channel und die darunter liegende States zu definieren\n         *\n         * bei def =  {id: Pfadname}\n         * gibts kein Problem mit channels... scheint mir die beste L\u00F6sung zu sein\n         * Pfade die als Erinnerungshilfe ohne name und instance\n         * provider.dwd.*warncellid*.warnung*1-5*\n         */\n    }\n\n    /**\n     * Get the ioBroker.Object out of stateDefinition\n     *\n     * @param key is the deep linking key to the definition\n     * @param data  is the definition dataset\n     * @returns ioBroker.ChannelObject | ioBroker.DeviceObject &| ioBroker.StateObject/s\n     */\n    async getObjectDefFromJson(key: string, data: any): Promise<ioBroker.Object> {\n        let result = await jsonata(`${key}`).evaluate(data);\n        if (result === null || result === undefined) {\n            this.log.warn(`No definition for ${key}!`);\n            result = genericStateObjects.state;\n        }\n        return this.cloneObject(result);\n    }\n\n    /**\n     * Get a channel/device definition from property _channel out of a getObjectDefFromJson() result or a default definition.\n     *\n     * @param def the data coming from getObjectDefFromJson()\n     * @returns ioBroker.ChannelObject | ioBroker.DeviceObject or a default channel obj\n     */\n    getChannelObject(\n        definition: (ioBroker.Object & { _channel?: ioBroker.Object }) | null = null,\n    ): ioBroker.ChannelObject | ioBroker.DeviceObject {\n        const def = (definition && definition._channel) || null;\n        const result: ioBroker.ChannelObject | ioBroker.DeviceObject = {\n            _id: def ? def._id : '',\n            type: def && def.type != 'device' ? 'channel' : 'device',\n            common: {\n                name: (def && def.common && def.common.name) || 'no definition',\n            },\n            native: (def && def.native) || {},\n        };\n        return result;\n    }\n\n    /**\n     * Write/Create the specified data point with value, will only be written if val != oldval and obj.type == state or the data point value in the DB is not undefined. Channel and Devices have an undefined value.\n     * @param dp Data point to be written. Library.clean() is called with it.\n     * @param val Value for this data point. Channel vals (old and new) are undefined so they never will be written.\n     * @param obj The object definition for this data point (ioBroker.ChannelObject | ioBroker.DeviceObject | ioBroker.StateObject)\n     * @returns void\n     */\n    async writedp(dp: string, val: ioBroker.StateValue | undefined, obj: ioBroker.Object | null = null): Promise<void> {\n        dp = this.cleandp(dp);\n        let node = this.readdp(dp);\n        const del = !this.isDirAllowed(dp);\n\n        if (node === undefined) {\n            if (!obj) {\n                throw new Error('writedp try to create a state without object informations.');\n            }\n            obj._id = `${this.adapter.name}.${this.adapter.instance}.${dp}`;\n            if (!del) await this.adapter.setObjectNotExistsAsync(dp, obj);\n            const stateType = obj && obj.common && obj.common.type;\n            node = this.setdb(dp, obj.type, undefined, stateType, true);\n        }\n\n        if (obj && obj.type !== 'state') return;\n\n        if (node) this.setdb(dp, node.type, val, node.stateTyp, true);\n\n        if (node && node.val != val) {\n            const typ = (obj && obj.common && obj.common.type) || node.stateTyp;\n            if (typ && typ != typeof val && val !== undefined) val = this.convertToType(val, typ);\n            if (!del)\n                await this.adapter.setStateAsync(dp, {\n                    val: val,\n                    ts: Date.now(),\n                    ack: true,\n                });\n        }\n    }\n    isDirAllowed(dp: string): boolean {\n        for (const a in this.allowedDirs) {\n            if (dp.search(new RegExp(this.allowedDirs[a], 'g')) != -1) {\n                if (dp.search('uwz') != -1) this.log.debug(dp + ' ' + this.allowedDirs[a]);\n                return false;\n            }\n        }\n        return true;\n    }\n\n    async cleanUpTree(hold: string[], deep: number): Promise<void> {\n        const del = [];\n        for (const dp in this.stateDataBase) {\n            if (hold.filter((a) => dp.startsWith(a)).length > 0) continue;\n            this.stateDataBase[dp] = undefined;\n            if (hold.filter((a) => dp.startsWith(a)).length > 0) continue;\n            del.push(dp.split('.').slice(0, deep).join('.'));\n        }\n        for (const a in del) {\n            this.adapter.delObjectAsync(del[a], { recursive: true });\n        }\n    }\n    /**\n     * Remove forbidden chars from datapoint string.\n     * @param string Datapoint string to clean\n     * @param lowerCase lowerCase() first param.\n     * @returns void\n     */\n    cleandp(string: string, lowerCase: boolean = false): string {\n        if (!string && typeof string != 'string') return string;\n\n        string = string.replace(this.adapter.FORBIDDEN_CHARS, '#');\n\n        return lowerCase ? string.toLowerCase() : string;\n    }\n    /* Convert a value to the given type\n     * @param {string|boolean|number} value \tthen value to convert\n     * @param {string}   type  \t\t\t\t\tthe target type\n     * @returns\n     */\n    convertToType(value: ioBroker.StateValue | Array<any> | JSON, type: string): ioBroker.StateValue {\n        if (value === null) return null;\n        if (type === undefined) {\n            throw new Error('convertToType type undefifined not allowed!');\n        }\n        if (value === undefined) value = '';\n\n        const old_type = typeof value;\n        let newValue: ioBroker.StateValue = typeof value == 'object' ? JSON.stringify(value) : value;\n\n        if (type !== old_type) {\n            switch (type) {\n                case 'string':\n                    newValue = value.toString() || '';\n                    break;\n                case 'number':\n                    newValue = value ? Number(value) : 0;\n                    break;\n                case 'boolean':\n                    newValue = !!value;\n                    break;\n                case 'array':\n                case 'json':\n                    //JSON.stringify() is done before\n                    break;\n            }\n        }\n        // get a warning message when we try to convert a object/array.\n        return newValue;\n    }\n    setdb(\n        dp: string,\n        type: ioBroker.ObjectType,\n        val: ioBroker.StateValue | undefined,\n        stateType: string | undefined,\n        ack: boolean = true,\n        ts: number = Date.now(),\n    ): LibraryStateVal {\n        this.stateDataBase[dp] = {\n            type: type,\n            stateTyp: stateType,\n            val: val,\n            ack: ack,\n            ts: ts ? ts : Date.now(),\n        };\n        return this.stateDataBase[dp];\n    }\n    getdb(dp: string): LibraryStateVal | undefined {\n        return this.stateDataBase[dp];\n    }\n    cloneObject(obj: ioBroker.Object): ioBroker.Object {\n        if (typeof obj !== 'object') {\n            this.log.error(`Error clone object target is type: ${typeof obj}`);\n            return obj;\n        }\n        return JSON.parse(JSON.stringify(obj));\n    }\n    cloneGenericObject(obj: object): object {\n        if (typeof obj !== 'object') {\n            this.log.error(`Error clone object target is type: ${typeof obj}`);\n            return obj;\n        }\n        return JSON.parse(JSON.stringify(obj));\n    }\n    readdp(dp: string): LibraryStateVal {\n        return this.stateDataBase[this.cleandp(dp)];\n    }\n    async readWithJsonata(\n        data: object,\n        cmd: { [key: string]: string } | string,\n    ): Promise<string | { [key: string]: string }> {\n        let result: any;\n        if (typeof cmd === 'string') {\n            if (cmd === '') return '';\n            try {\n                result = await jsonata(cmd).evaluate(data);\n            } catch (error: any) {\n                this.log.error(error.message);\n                this.log.error(`The cmd: ${cmd} is invaild Message: ${error.message}.`);\n            }\n        } else {\n            result = {};\n            for (const k in cmd) {\n                if (cmd[k]) {\n                    try {\n                        result[k] = await jsonata(cmd[k]).evaluate(data);\n                    } catch (error: any) {\n                        this.log.error(error);\n                        this.log.error(`The cmd: ${cmd[k]} for key ${k} is invaild.`);\n                    }\n                }\n            }\n        }\n        return result;\n    }\n    /**\n     * Initialise the database with the states to prevent unnecessary creation and writing.\n     * @param states States that are to be read into the database during initialisation.\n     * @returns void\n     */\n    async initStates(states: { [key: string]: { val: ioBroker.StateValue; ts: number; ack: boolean } }): Promise<void> {\n        if (!states) return;\n        for (const state in states) {\n            const dp = state.replace(`${this.adapter.name}.${this.adapter.instance}.`, '');\n            const del = !this.isDirAllowed(dp);\n            if (!del) {\n                const obj = await this.adapter.getObjectAsync(dp);\n                if (!this.adapter.config.useJsonHistory && dp.endsWith('.warning.jsonHistory')) {\n                    await this.adapter.delStateAsync(dp);\n                    continue;\n                }\n                this.setdb(\n                    dp,\n                    'state',\n                    states[state] && states[state].val ? states[state].val : undefined,\n                    obj && obj.common && obj.common.type ? obj.common.type : undefined,\n                    states[state] && states[state].ack,\n                    states[state] && states[state].ts ? states[state].ts : Date.now(),\n                );\n            } else {\n                this.adapter.log.debug('Delete State: ' + dp);\n                await this.adapter.delStateAsync(dp);\n            }\n        }\n    }\n\n    /**\n     * Resets states that have not been updated in the database in offset time.\n     * @param prefix String with which states begin that are reset.\n     * @param offset Time in ms since last update.\n     * @returns void\n     */\n    async garbageColleting(prefix: string, offset: number = 2000): Promise<void> {\n        if (!prefix) return;\n        if (this.stateDataBase) {\n            for (const id in this.stateDataBase) {\n                if (id.startsWith(prefix)) {\n                    const state = this.stateDataBase[id];\n                    if (!state || state.val == undefined) continue;\n                    if (state.ts < Date.now() - offset) {\n                        let newVal: -1 | '' | '{}' | '[]' | false | null | undefined;\n                        switch (state.stateTyp) {\n                            case 'string':\n                                if (typeof state.val == 'string') {\n                                    if (state.val.startsWith('{') && state.val.endsWith('}')) newVal = '{}';\n                                    else if (state.val.startsWith('[') && state.val.endsWith(']')) newVal = '[]';\n                                    else newVal = '';\n                                } else newVal = '';\n                                break;\n                            case 'bigint':\n                            case 'number':\n                                newVal = -1;\n                                break;\n\n                            case 'boolean':\n                                newVal = false;\n                                break;\n                            case 'symbol':\n                            case 'object':\n                            case 'function':\n                                newVal = null;\n                                break;\n                            case 'undefined':\n                                newVal = undefined;\n                                break;\n                        }\n                        await this.writedp(id, newVal);\n                    }\n                }\n            }\n        }\n    }\n\n    async getTranslation2(text: string | { [key: string]: string }): Promise<string> {\n        if (typeof text == 'object') {\n            if (!this.language) {\n                const obj = await this.adapter.getForeignObjectAsync('system.config');\n                if (obj) this.language = obj.common.language;\n\n                if (!this.language) this.language = 'en';\n            }\n            if (!text[this.language]) return text['en'];\n            return text[this.language];\n        } else return text;\n    }\n    getLocalLanguage(): string {\n        if (this.language) return this.language;\n        return 'en-En';\n    }\n    async getTranslation(key: string): Promise<string> {\n        const language = await import(`../../admin/i18n/${this.language}/translations.json`);\n        if (language && language[key] !== undefined) return language[key];\n        return key;\n    }\n    async setLanguage(language: string): Promise<void> {\n        if (!language) language = 'en';\n        this.language = language;\n        this.translation = await import(`../../admin/i18n/${language}/translations.json`);\n    }\n    async updateTranslations(): Promise<void> {\n        return;\n        writefile('textLevels', textLevels);\n        for (const l in customFormatedTokensJson) {\n            const key = 'customFormatedTokensJson.' + l;\n            const translation = geti18nTranslation(key);\n            //@ts-expect-error faulheit\n            if (customFormatedTokensJson[l] !== '') {\n                if (translation != '' && typeof translation == 'object') {\n                    //@ts-expect-error faulheit\n                    customFormatedTokensJson[l] = key;\n                } else {\n                    //@ts-expect-error faulheit\n                    seti18nTranslation(key, customFormatedTokensJson[l]);\n                }\n            }\n        }\n        writefile('customFormatedTokensJson', customFormatedTokensJson);\n        //await writei18nTranslation();\n    }\n    setAllowedDirs(dirs: any[]): void {\n        this.allowedDirs = this.allowedDirs.concat(dirs);\n    }\n}\n"],
  "mappings": "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",
  "names": ["jsonata"]
}
